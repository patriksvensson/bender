// <auto-generated/>

namespace Bender.Json;

using System;
using System.Collections.Generic;
using System.Globalization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;

/// <summary>
/// Defines the .NET Aspire 8.0 deployment manifest JSON schema.
/// </summary>
public sealed class AspireJsonModel
{
    /// <summary>
    /// Contains the set of resources deployable as part of this manifest. Each property is a
    /// distinct resource.
    /// </summary>
    [JsonProperty("resources", Required = Required.Always)]
    public Dictionary<string, Resource> Resources { get; set; }

    /// <summary>
    /// A resource that represents a Dockerfile that will be built into a container duing
    /// deployment.
    ///
    /// A generic container resource.
    ///
    /// Represents a .NET project resource.
    ///
    /// Represents an executable resource.
    ///
    /// Represents a value resource. Typically used to perform string concatenation (e.g. for
    /// connection strings).
    ///
    /// Represents a parameter resource. Parameter resources are used to represent external
    /// configuration values that should be provided at deployment time.
    ///
    /// Represents a Dapr resource in the manifest.
    ///
    /// Represents extensions. Any object with a 'type' field that is not captured above will
    /// pass.
    /// </summary>
    public partial class Resource
    {
        [JsonProperty("type", Required = Required.Always)]
        public string Type { get; set; }

        [JsonProperty("bindings", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, Binding> Bindings { get; set; }

        /// <summary>
        /// A directory path used as the context for building the Dockerfile into a container image.
        /// </summary>
        [JsonProperty("context", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Context { get; set; }

        [JsonProperty("env", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, string> Env { get; set; }

        /// <summary>
        /// The file path to the Dockerfile to be built into a container image.
        ///
        /// The path to the project file. Relative paths are interpreted as being relative to the
        /// location of the manifest file.
        ///
        /// Path to the Bicep file to be used for deployment.
        /// </summary>
        [JsonProperty("path", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Path { get; set; }

        [JsonProperty("args", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<string> Args { get; set; }

        [JsonProperty("bindMounts", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<BindMount> BindMounts { get; set; }

        [JsonProperty("connectionString", Required = Required.DisallowNull,
            NullValueHandling = NullValueHandling.Ignore)]
        public string ConnectionString { get; set; }

        /// <summary>
        /// The entrypoint to use for the container image when executed.
        /// </summary>
        [JsonProperty("entrypoint", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Entrypoint { get; set; }

        /// <summary>
        /// A string representing the container image to be used.
        /// </summary>
        [JsonProperty("image", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Image { get; set; }

        [JsonProperty("volumes", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<Volume> Volumes { get; set; }

        /// <summary>
        /// The path to the command. Should be interpreted as being relative to the AppHost directory.
        /// </summary>
        [JsonProperty("command", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Command { get; set; }

        /// <summary>
        /// The path to the working directory. Should be intepretted as being relative to the AppHost
        /// directory.
        /// </summary>
        [JsonProperty("workingDirectory", Required = Required.DisallowNull,
            NullValueHandling = NullValueHandling.Ignore)]
        public string WorkingDirectory { get; set; }

        /// <summary>
        /// Defines a set of input values which need to be either generated or prompted by the
        /// deployment tool. This is typically used for environment specific configuration values or
        /// secrets.
        /// </summary>
        [JsonProperty("inputs", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, Input> Inputs { get; set; }

        [JsonProperty("value", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Value { get; set; }

        /// <summary>
        /// Dapr specific configuration.
        /// </summary>
        [JsonProperty("dapr", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Dapr Dapr { get; set; }

        [JsonProperty("daprComponent", Required = Required.DisallowNull,
            NullValueHandling = NullValueHandling.Ignore)]
        public DaprComponent DaprComponent { get; set; }

        /// <summary>
        /// A list of parameters which are passed to Azure deployment.
        /// </summary>
        [JsonProperty("params", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Dictionary<string, Param> Params { get; set; }

        [JsonProperty("references", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public List<Reference> References { get; set; }

        [JsonProperty("stack-name", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string StackName { get; set; }

        [JsonProperty("template-path", Required = Required.DisallowNull,
            NullValueHandling = NullValueHandling.Ignore)]
        public string TemplatePath { get; set; }
    }

    /// <summary>
    /// A list of bind mounts associated with this resource when deployed.
    /// </summary>
    public partial class BindMount
    {
        /// <summary>
        /// Flag indicating whether the mount is read-only.
        /// </summary>
        [JsonProperty("readOnly", Required = Required.Always)]
        public bool ReadOnly { get; set; }

        /// <summary>
        /// The source path on the host which is mounted into the container.
        /// </summary>
        [JsonProperty("source", Required = Required.Always)]
        public string Source { get; set; }

        /// <summary>
        /// The target within the container where the volume is mounted.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public string Target { get; set; }
    }

    public partial class Binding
    {
        /// <summary>
        /// A flag indicating whether this binding is exposed externally when deployed.
        /// </summary>
        [JsonProperty("external", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? External { get; set; }

        /// <summary>
        /// The port that the workload (e.g. container) is exposed as to other resources and
        /// externally.
        /// </summary>
        [JsonProperty("port", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? Port { get; set; }

        /// <summary>
        /// The protocol used for this binding (only 'tcp' or 'udp' are valid).
        /// </summary>
        [JsonProperty("protocol", Required = Required.Always)]
        public Protocol Protocol { get; set; }

        /// <summary>
        /// The scheme used in URIs for this binding.
        /// </summary>
        [JsonProperty("scheme", Required = Required.Always)]
        public Scheme Scheme { get; set; }

        /// <summary>
        /// The port that the workload (e.g. container) is listening on.
        /// </summary>
        [JsonProperty("targetPort", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? TargetPort { get; set; }

        /// <summary>
        /// Additional information describing the transport (e.g. HTTP/2).
        /// </summary>
        [JsonProperty("transport", Required = Required.Always)]
        public Transport Transport { get; set; }
    }

    /// <summary>
    /// Dapr specific configuration.
    /// </summary>
    public partial class Dapr
    {
        [JsonProperty("appId", Required = Required.Always)]
        public string AppId { get; set; }

        [JsonProperty("application", Required = Required.Always)]
        public string Application { get; set; }

        [JsonProperty("components", Required = Required.Always)]
        public List<string> Components { get; set; }
    }

    public partial class DaprComponent
    {
        [JsonProperty("type", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public string Type { get; set; }
    }

    public partial class Input
    {
        [JsonProperty("default", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public Default Default { get; set; }

        /// <summary>
        /// Flag indicating whether the value should be treated as a secret. Deployment tools should
        /// note this value to take appropriate precautions when prompting, storing, and transmitting
        /// this value.
        /// </summary>
        [JsonProperty("secret", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? Secret { get; set; }

        /// <summary>
        /// The type of the value to be prompted or generated. Currently only 'string'' is supported.
        /// </summary>
        [JsonProperty("type", Required = Required.Always)]
        public TypeEnum Type { get; set; }
    }

    public partial class Default
    {
        [JsonProperty("generate", Required = Required.Always)]
        public Generate Generate { get; set; }
    }

    public partial class Generate
    {
        /// <summary>
        /// Indicates whether lower case characters are allowed in the generated value.
        /// </summary>
        [JsonProperty("lower", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? Lower { get; set; }

        /// <summary>
        /// The minimum length of the generated value.
        /// </summary>
        [JsonProperty("minLength", Required = Required.Always)]
        public double MinLength { get; set; }

        /// <summary>
        /// Specifies the minimum number of lower case characters that must appear in the generated
        /// value.
        /// </summary>
        [JsonProperty("minLower", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? MinLower { get; set; }

        /// <summary>
        /// Specifies the minimum number of numeric characters that must appear in the generated
        /// value.
        /// </summary>
        [JsonProperty("minNumeric", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? MinNumeric { get; set; }

        /// <summary>
        /// Specifies the minimum number of special characters that must appear in the generated
        /// value.
        /// </summary>
        [JsonProperty("minSpecial", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? MinSpecial { get; set; }

        /// <summary>
        /// Specifies the minimum number of upper case characters that must appear in the generated
        /// value.
        /// </summary>
        [JsonProperty("minUpper", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public double? MinUpper { get; set; }

        /// <summary>
        /// Indicates whether numeric characters are allowed in the generated value.
        /// </summary>
        [JsonProperty("numeric", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? Numeric { get; set; }

        /// <summary>
        /// Indicates whether special characters are allowed in the generated value.
        /// </summary>
        [JsonProperty("special", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? Special { get; set; }

        /// <summary>
        /// Indicates whether upper case characters are allowed in the generated value.
        /// </summary>
        [JsonProperty("upper", Required = Required.DisallowNull, NullValueHandling = NullValueHandling.Ignore)]
        public bool? Upper { get; set; }
    }

    public partial class Reference
    {
        [JsonProperty("target-resource", Required = Required.DisallowNull,
            NullValueHandling = NullValueHandling.Ignore)]
        public string TargetResource { get; set; }
    }

    /// <summary>
    /// A list of volumes associated with this resource when deployed.
    /// </summary>
    public partial class Volume
    {
        /// <summary>
        /// The name of the volume.
        /// </summary>
        [JsonProperty("name", Required = Required.Always)]
        public string Name { get; set; }

        /// <summary>
        /// Flag indicating whether the mount is read-only.
        /// </summary>
        [JsonProperty("readOnly", Required = Required.Always)]
        public bool ReadOnly { get; set; }

        /// <summary>
        /// The target within the container where the volume is mounted.
        /// </summary>
        [JsonProperty("target", Required = Required.Always)]
        public string Target { get; set; }
    }

    /// <summary>
    /// The protocol used for this binding (only 'tcp' or 'udp' are valid).
    /// </summary>
    public enum Protocol { Tcp, Udp };

    /// <summary>
    /// The scheme used in URIs for this binding.
    /// </summary>
    public enum Scheme { Http, Https, Tcp, Udp };

    /// <summary>
    /// Additional information describing the transport (e.g. HTTP/2).
    /// </summary>
    public enum Transport { Http, Http2, Tcp };

    /// <summary>
    /// The type of the value to be prompted or generated. Currently only 'string'' is supported.
    /// </summary>
    public enum TypeEnum { String };

    public partial struct Param
    {
        public List<object> AnythingArray;
        public Dictionary<string, object> AnythingMap;
        public bool? Bool;
        public double? Double;
        public string String;

        public static implicit operator Param(List<object> AnythingArray) =>
            new Param { AnythingArray = AnythingArray };

        public static implicit operator Param(Dictionary<string, object> AnythingMap) =>
            new Param { AnythingMap = AnythingMap };

        public static implicit operator Param(bool Bool) => new Param { Bool = Bool };
        public static implicit operator Param(double Double) => new Param { Double = Double };
        public static implicit operator Param(string String) => new Param { String = String };
    }

    internal static class Converter
    {
        public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
        {
            MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
            DateParseHandling = DateParseHandling.None,
            Converters =
            {
                ProtocolConverter.Singleton,
                SchemeConverter.Singleton,
                TransportConverter.Singleton,
                TypeEnumConverter.Singleton,
                ParamConverter.Singleton,
                new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal }
            },
        };
    }

    internal class ProtocolConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Protocol) || t == typeof(Protocol?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "tcp":
                    return Protocol.Tcp;
                case "udp":
                    return Protocol.Udp;
            }

            throw new Exception("Cannot unmarshal type Protocol");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }

            var value = (Protocol)untypedValue;
            switch (value)
            {
                case Protocol.Tcp:
                    serializer.Serialize(writer, "tcp");
                    return;
                case Protocol.Udp:
                    serializer.Serialize(writer, "udp");
                    return;
            }

            throw new Exception("Cannot marshal type Protocol");
        }

        public static readonly ProtocolConverter Singleton = new ProtocolConverter();
    }

    internal class SchemeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Scheme) || t == typeof(Scheme?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "http":
                    return Scheme.Http;
                case "https":
                    return Scheme.Https;
                case "tcp":
                    return Scheme.Tcp;
                case "udp":
                    return Scheme.Udp;
            }

            throw new Exception("Cannot unmarshal type Scheme");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }

            var value = (Scheme)untypedValue;
            switch (value)
            {
                case Scheme.Http:
                    serializer.Serialize(writer, "http");
                    return;
                case Scheme.Https:
                    serializer.Serialize(writer, "https");
                    return;
                case Scheme.Tcp:
                    serializer.Serialize(writer, "tcp");
                    return;
                case Scheme.Udp:
                    serializer.Serialize(writer, "udp");
                    return;
            }

            throw new Exception("Cannot marshal type Scheme");
        }

        public static readonly SchemeConverter Singleton = new SchemeConverter();
    }

    internal class TransportConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Transport) || t == typeof(Transport?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "http":
                    return Transport.Http;
                case "http2":
                    return Transport.Http2;
                case "tcp":
                    return Transport.Tcp;
            }

            throw new Exception("Cannot unmarshal type Transport");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }

            var value = (Transport)untypedValue;
            switch (value)
            {
                case Transport.Http:
                    serializer.Serialize(writer, "http");
                    return;
                case Transport.Http2:
                    serializer.Serialize(writer, "http2");
                    return;
                case Transport.Tcp:
                    serializer.Serialize(writer, "tcp");
                    return;
            }

            throw new Exception("Cannot marshal type Transport");
        }

        public static readonly TransportConverter Singleton = new TransportConverter();
    }

    internal class TypeEnumConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(TypeEnum) || t == typeof(TypeEnum?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "string")
            {
                return TypeEnum.String;
            }

            throw new Exception("Cannot unmarshal type TypeEnum");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }

            var value = (TypeEnum)untypedValue;
            if (value == TypeEnum.String)
            {
                serializer.Serialize(writer, "string");
                return;
            }

            throw new Exception("Cannot marshal type TypeEnum");
        }

        public static readonly TypeEnumConverter Singleton = new TypeEnumConverter();
    }

    internal class ParamConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(Param) || t == typeof(Param?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            switch (reader.TokenType)
            {
                case JsonToken.Integer:
                case JsonToken.Float:
                    var doubleValue = serializer.Deserialize<double>(reader);
                    return new Param { Double = doubleValue };
                case JsonToken.Boolean:
                    var boolValue = serializer.Deserialize<bool>(reader);
                    return new Param { Bool = boolValue };
                case JsonToken.String:
                case JsonToken.Date:
                    var stringValue = serializer.Deserialize<string>(reader);
                    return new Param { String = stringValue };
                case JsonToken.StartObject:
                    var objectValue = serializer.Deserialize<Dictionary<string, object>>(reader);
                    return new Param { AnythingMap = objectValue };
                case JsonToken.StartArray:
                    var arrayValue = serializer.Deserialize<List<object>>(reader);
                    return new Param { AnythingArray = arrayValue };
            }

            throw new Exception("Cannot unmarshal type Param");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            var value = (Param)untypedValue;
            if (value.Double != null)
            {
                serializer.Serialize(writer, value.Double.Value);
                return;
            }

            if (value.Bool != null)
            {
                serializer.Serialize(writer, value.Bool.Value);
                return;
            }

            if (value.String != null)
            {
                serializer.Serialize(writer, value.String);
                return;
            }

            if (value.AnythingArray != null)
            {
                serializer.Serialize(writer, value.AnythingArray);
                return;
            }

            if (value.AnythingMap != null)
            {
                serializer.Serialize(writer, value.AnythingMap);
                return;
            }

            throw new Exception("Cannot marshal type Param");
        }

        public static readonly ParamConverter Singleton = new ParamConverter();
    }
}